<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="public/favicon.ico">
    <script src="https://cdn.tailwindcss.com/"></script>
    <script src="//unpkg.com/alpinejs" defer></script>
    <title>aufbau</title>
    <link rel="stylesheet" href="./index.css">
  </head>

  <body class="absolute inset-0 off-black">

    <div id="title" class="flex justify-center">
        <span class="large-text">
          aufbau.
        </span>
        <span class="medium-text">
          Digital Construction Studio
        </span>
    </div>

    <div id="three">
    </div>

  </body>

  
  <script type="module">
    
    import * as THREE from 'three';

    let camera, scene, renderer;
    let plane;
    let pointer, raycaster, isShiftDown = false;

    let rollOverMesh, rollOverMaterial;
    let cubeGeo, cubeMaterial;

    let width = window.innerWidth 

    let aspect = width / window.innerHeight;
    let d = 200;

    const objects = [];

    init();
    render();

    function init() {

      camera = new THREE.OrthographicCamera( - d * aspect, d * aspect, d, - d, 1, 1000 );
      camera.position.set( 200, 200, 200 );
      camera.lookAt( 0, 0, 0 );

      scene = new THREE.Scene();
      scene.background = new THREE.Color( 0x232323 );

      // roll-over helpers

      const rollOverGeo = new THREE.BoxGeometry( 50, 50, 50 );
      rollOverMaterial = new THREE.MeshBasicMaterial( { color: 0xfeb74c, opacity: 0.2, transparent: true } );
      rollOverMesh = new THREE.Mesh( rollOverGeo, rollOverMaterial );
      scene.add( rollOverMesh );

      // cubes

      cubeGeo = new THREE.BoxGeometry( 50, 50, 50 );
      cubeMaterial = new THREE.MeshLambertMaterial( { color: 0xfeb74c} );

      // grid

      const gridHelper = new THREE.GridHelper( 2000, 40, 0x404040, 0x404040);
      scene.add( gridHelper );

      //

      raycaster = new THREE.Raycaster();
      pointer = new THREE.Vector2();

      const geometry = new THREE.PlaneGeometry( 1000, 1000 );
      geometry.rotateX( - Math.PI / 2 );

      plane = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( {visible: false } ) );
      scene.add( plane );

      objects.push( plane );

      // lights

      const ambientLight = new THREE.AmbientLight( 0x606060 );
      scene.add( ambientLight );

      const directionalLight = new THREE.DirectionalLight( 0xffffff );
      directionalLight.position.set( 1, 0.75, 0.5 ).normalize();
      scene.add( directionalLight );

      renderer = new THREE.WebGLRenderer( { antialias: true } );
      renderer.setPixelRatio( window.devicePixelRatio );
      renderer.setSize( width, window.innerHeight );
      document.getElementById("three").appendChild( renderer.domElement );

      document.addEventListener( 'pointermove', onPointerMove );
      document.addEventListener( 'pointerdown', onPointerDown );
      document.addEventListener( 'keydown', onDocumentKeyDown );
      document.addEventListener( 'keyup', onDocumentKeyUp );

      //

      window.addEventListener( 'resize', onWindowResize );

    }

    function onWindowResize() {

      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize( window.innerWidth, window.innerHeight );

      render();

    }

    function onPointerMove( event ) {

      pointer.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

      raycaster.setFromCamera( pointer, camera );

      const intersects = raycaster.intersectObjects( objects, false );

      if ( intersects.length > 0 ) {

        const intersect = intersects[ 0 ];

        rollOverMesh.position.copy( intersect.point ).add( intersect.face.normal );
        rollOverMesh.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );

        render();

      }

    }

    function onPointerDown( event ) {

      pointer.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

      raycaster.setFromCamera( pointer, camera );

      const intersects = raycaster.intersectObjects( objects, false );

      if ( intersects.length > 0 ) {

        const intersect = intersects[ 0 ];

        // delete cube

        if ( isShiftDown ) {

          if ( intersect.object !== plane ) {

            scene.remove( intersect.object );

            objects.splice( objects.indexOf( intersect.object ), 1 );

          }

          // create cube

        } else {

          const voxel = new THREE.Mesh( cubeGeo, cubeMaterial );
          voxel.position.copy( intersect.point ).add( intersect.face.normal );
          voxel.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );
          scene.add( voxel );

          objects.push( voxel );

        }

        render();

      }

    }

    function onDocumentKeyDown( event ) {

      switch ( event.keyCode ) {

        case 16: isShiftDown = true; break;

      }

    }

    function onDocumentKeyUp( event ) {

      switch ( event.keyCode ) {

        case 16: isShiftDown = false; break;

      }

    }

    function render() {

      renderer.render( scene, camera );

    }

  </script>

</html

